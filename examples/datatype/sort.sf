data PolyList A = Nil
     	        | Cons A (PolyList A)
	        ;

let rec eq A (xs: PolyList A) (ys: PolyList A) : Bool =
  case xs of
     Nil -> (case ys of
              Nil -> True
	    | Cons z zs -> False)
   | Cons a as -> (case ys of
     	       	     Nil -> False
		   | Cons b bs -> (a == b) && (eq A as bs)) ;
let rec filter (p : Int -> Bool) (xs : PolyList Int) : PolyList Int =
  case xs of
      Nil       -> {Nil Int}
    | Cons y ys -> if p y then { Cons Int y (filter p ys) } else filter p ys;
let rec concat A (xs : PolyList A) (ys : PolyList A) : PolyList A =
  case xs of
      Nil       -> ys
    | Cons z zs -> { Cons A z (concat A zs ys) };
let rec qsort (xs : PolyList Int) : PolyList Int =
  case xs of
      Nil       -> {Nil Int}
    | Cons y ys -> case ys of
                       Nil       -> { Cons Int y {Nil Int} }
                     | Cons z zs -> concat Int (qsort (filter (\(a : Int). a <= y) ys)) {Cons Int y (qsort (filter (\(a : Int). a > y) ys)) };
let rec insert (x : Int) (xs : PolyList Int) : PolyList Int =
    case xs of
        Nil -> {Cons Int x {Nil Int}}
      | Cons y ys -> if x <= y
      	       	     then {Cons Int x {Cons Int y ys}}
		     else {Cons Int y (insert x ys)};
let rec isort (xs : PolyList Int) : PolyList Int =
    case xs of
    	Nil -> {Nil Int}
      | Cons x ys -> insert x (isort ys);
let prop_sort (xs : PolyList Int) = eq Int (qsort xs) (isort xs);
prop_sort
