type ListAlg[A, L] = {
  nil  : L,
  cons : A -> L -> L
};
type MyList[A] = {
  accept : forall L. ListAlg[A, L] -> L
};
let sumListAlg : ListAlg[Int, Int] = {
  nil  = 0,
  cons = \(x : Int) (y : Int) -> x + y
};
let sumList (l : MyList[Int]) : Int =
  l.accept[Int] sumListAlg;
type SybAlg[Company, Dept, SubUnit, Employee, Person, Salary] = {
  goC  : MyList[Dept]  ->  Company,
  goD  : String       ->  Employee  ->  MyList[SubUnit]  ->  Dept,
  goPU : Employee     ->  SubUnit,
  goDU : Dept         ->  SubUnit,
  goE  : Person       ->  Salary    ->  Employee,
  goP  : String       ->  String    ->  Person,
  goS  : Int          ->  Salary
};
let staff[C, D, SU, E, P, SA] (alg : SybAlg[C, D, SU, E, P, SA]) = {
  ralf   = alg.goE (alg.goP "Ralf"   "Amsterdam") (alg.goS 8000),
  joost  = alg.goE (alg.goP "Joost"  "Amsterdam") (alg.goS 1000),
  marlow = alg.goE (alg.goP "Marlow" "Cambridge") (alg.goS 2000),
  blair  = alg.goE (alg.goP "Blair"  "London")    (alg.goS 100000)
};
let genCom[C, D, SU, E, P, SA] (alg : SybAlg[C, D, SU, E, P, SA]) : C =
  alg.goC
  { accept = /\L -> \(f : ListAlg[D, L]) -> f.cons
      (alg.goD "Research" ((staff[C, D, SU, E, P, SA] alg).ralf)
      { accept = /\LM -> \(fm : ListAlg[SU, LM]) -> fm.cons
          (alg.goPU ((staff[C, D, SU, E, P, SA] alg).joost)) (fm.cons
           alg.goPU ((staff[C, D, SU, E, P, SA] alg).marlow) fm.nil) }) (f.cons
    (alg.goD "Strategy" ((staff[C, D, SU, E, P, SA] alg).blair)
      { accept = /\LN -> \(fn : ListAlg[SU, LN]) -> fn.nil }) f.nil) };
type QueryInt = SybAlg[Int, Int, Int, Int, Int, Int];
let salaryBill : QueryInt = {
  goC  = \(l : MyList[Int]) -> sumList l,
  goD  = \(x : String) (y : Int) (l : MyList[Int]) -> y + sumList l,
  goPU = \(x : Int) -> x,
  goDU = \(x : Int) -> x,
  goE  = \(x : Int) (y : Int) -> x + y,
  goP  = \(x : String) (y : String) -> 0,
  goS  = \(x : Int) -> x
};
genCom [Int, Int, Int, Int, Int, Int] salaryBill
